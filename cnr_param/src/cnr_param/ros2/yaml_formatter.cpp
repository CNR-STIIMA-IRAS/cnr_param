
#include <yaml-cpp/node/node.h>
#include <yaml-cpp/node/type.h>
#include <iterator>
#include <iostream>

#include <cnr_param/core/string.h>
#include <cnr_param/ros2/yaml_formatter.h>

namespace cnr
{
namespace param
{
namespace ros2
{

/**
 * @brief
 *
 * @param node
 * @return YAML::Node
 */
bool ros2_yaml_encoder(const YAML::Node& node, YAML::Node& ret, std::string& what)
{
  if (node.IsScalar())
  {
    ret = node;
    return true;
  }

  for (auto it = node.begin(); it != node.end(); it++)
  {
    if (!it->first.IsScalar())
    {
      what += std::string(what.length() > 0 ? "; " : "") + "WIP";
      ret.reset(YAML::Node(YAML::NodeType::Null));
      return false;
    }
    std::string key = it->first.Scalar();
    if (key[0] == '/')
    {
      key = key.substr(1);
    }

    //
    switch (it->second.Type())
    {
      case YAML::NodeType::Undefined: {
        what += std::string(what.length() > 0 ? "; " : "") +
                "The value is Undefined. This is not yet supported. Input Node: ''" + std::to_string(node) +
                "'' Abort.";
        ;
        ret.reset(YAML::Node(YAML::NodeType::Null));
        return false;
      }
      break;
      case YAML::NodeType::Null: {
        what += std::string(what.length() > 0 ? "; " : "") +
                "The value is Null. This is not yet supported. Input Node: ''" + std::to_string(node) + "'' Abort.";
        ;
        ret.reset(YAML::Node(YAML::NodeType::Null));
        return false;
      }
      break;
      case YAML::NodeType::Scalar: {
        ret[key] = it->second;
        return true;
      }
      break;
      case YAML::NodeType::Sequence: {
        const YAML::Node& seq = it->second;
        switch (seq[0].Type())
        {
          case YAML::NodeType::Undefined: {
            what += std::string(what.length() > 0 ? "; " : "") +
                    "The value of the first element of the sequence is Undefined. This is not yet supported. Input "
                    "Node: ''" +
                    std::to_string(node) + "'' Abort.";
            ;
            ret.reset(YAML::Node(YAML::NodeType::Null));
            return false;
          }
          break;
          case YAML::NodeType::Null: {
            what += std::string(what.length() > 0 ? "; " : "") +
                    "The value of the first element of the sequence is Null. This is not yet supported. Input Node: "
                    "''" +
                    std::to_string(node) + "'' Abort.";
            ;
            ret.reset(YAML::Node(YAML::NodeType::Null));
            return false;
          }
          break;
          case YAML::NodeType::Scalar: {
            ret.reset(YAML::Node(YAML::NodeType::Map));
            ret[key] = it->second;
            return true;
          }
          break;
          case YAML::NodeType::Sequence:
          case YAML::NodeType::Map: {
            auto key_autogenerated = key + "_autogenerated_from_sequence_of_" + std::to_string(seq[0].Type());
            YAML::Node leaf = YAML::Node(YAML::NodeType::Sequence);
            leaf["size"] = it->second.size();
            for (auto seq_it = seq.begin(); seq_it != seq.end(); seq_it++)
            {
              std::size_t i = std::distance(seq.begin(), seq_it);
              std::string record_key = "record_" + std::to_string(i);
              if (seq[0].IsSequence())
              {
                for (auto record_it = seq_it->begin(); record_it != seq_it->end(); record_it++)
                {
                  leaf[record_key].push_back(*record_it);
                }
              }
              else  // IsMap
              {
                YAML::Node tmp = *seq_it;
                leaf[record_key] = tmp;
              }
            }
            YAML::Node new_map = YAML::Node(YAML::NodeType::Map);
            if (!ros2_yaml_encoder(leaf, new_map, what))
            {
              return false;
            }
            ret[key_autogenerated] = new_map;
          }
          break;
        }
      }
      break;
      case YAML::NodeType::Map: {
        YAML::Node new_map = YAML::Node(YAML::NodeType::Map);
        if (!ros2_yaml_encoder(it->second, new_map, what))
        {
          return false;
        }
        ret[key] = new_map;
      }
      break;
    }
  }
  what += std::string(what.length() > 0 ? "; " : "") + ("WEIRD!!! Why am I here?");
  return false;
}

bool ros2_yaml_decoder(const YAML::Node& node, YAML::Node& ret, std::string& what)
{
  switch (node.Type())
  {
    case YAML::NodeType::Scalar: {
      ret = node;
      return true;
    }
    break;
    case YAML::NodeType::Sequence: {
      ret.reset(YAML::Node(YAML::NodeType::Sequence));
      for (auto it = node.begin(); it != node.end(); ++it)
      {
        YAML::Node leaf;
        if (!ros2_yaml_decoder(*it, leaf, what))
        {
          return false;
        }
        ret.push_back(leaf);
      }
      return true;
    }
    break;
    case YAML::NodeType::Map: {
      for (auto it = node.begin(); it != node.end(); ++it)
      {
        if (!it->first.IsScalar())
        {
          throw std::runtime_error("WIP");
        }
        std::string key = it->first.Scalar();
        if (key[0] == '/')
        {
          key = key.substr(1);
        }
        auto _pos = key.find("_autogenerated_from_sequence_of_");
        if (_pos == std::string::npos)
        {
          YAML::Node leaf;
          if (!ros2_yaml_decoder(it->second, leaf, what))
          {
            return false;
          }
          ret[key] = leaf;
        }
        else
        {
          std::string resolved_key = key.substr(0, _pos);
          if (!node[key]["size"])
          {
            what += std::string(what.length() > 0 ? "; " : "") +
                    ("The key " + key + " does not have the field 'size'. Input Node: ''" + std::to_string(node) +
                     "'' Abort.");
            ret.reset(YAML::Node(YAML::NodeType::Null));
            return false;
          }
          const std::size_t sz = node[key]["size"].as<std::size_t>();
          YAML::Node seq(YAML::NodeType::Sequence);
          for (std::size_t i = 0; i < sz; i++)
          {
            std::string r = "record_" + std::to_string(i);
            if (!node[key][r])
            {
              what += std::string(what.length() > 0 ? "; " : "") +
                      ("The key " + key + " does not have the field '" + r + "'. Input Node: ''" +
                       std::to_string(node) + "'' Abort.");
              ret.reset(YAML::Node(YAML::NodeType::Null));
              return false;
            }
            YAML::Node element;
            if (!ros2_yaml_decoder(node[key][r], element, what))
            {
              return false;
            }
            seq.push_back(element);
          }
          ret[resolved_key] = seq;
        }
      }
      return true;
    }
    break;
    default: {
      what += std::string(what.length() > 0 ? "; " : "") +
              ("The value is " + std::to_string(node.Type()) + ". This is not yet supported. Input Node: ''" +
               std::to_string(node) + "'' Abort.");
      ret.reset(YAML::Node(YAML::NodeType::Null));
      return false;
    }
    break;
  }
  what += std::string(what.length() > 0 ? "; " : "") + ("WEIRD!!! Why am I here?");
  ret.reset(YAML::Node(YAML::NodeType::Null));
  return false;
}

}  // namespace ros2
}  // namespace param
}  // namespace cnr