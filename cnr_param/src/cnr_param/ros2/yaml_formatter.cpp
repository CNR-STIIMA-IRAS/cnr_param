
#include <yaml-cpp/node/node.h>
#include <yaml-cpp/node/type.h>

#include <cnr_param/core/string.h>
#include <cnr_param/ros2/yaml_formatter.h>

namespace cnr
{
namespace param
{
namespace ros2
{

/**
 * @brief
 *
 * @param node
 * @return YAML::Node
 */
bool ros2_yaml_encoder(const YAML::Node& node, YAML::Node& ret, std::string& what)
{
  if (node.IsScalar())
  {
    ret = node;
    return true;
  }

  for (auto it = node.begin(); it != node.end(); it++)
  {
    auto & _key = it->first;
    auto & _value = it->second;
    if (!it->first.IsScalar())
    {
      what += std::string(what.length() > 0 ? "; " : "") + "WIP";
      ret.reset(YAML::Node(YAML::NodeType::Null));
      return false;
    }
    std::string key = _key.Scalar();
    if (key[0] == '/')
    {
      key = key.substr(1);
    }
    //
    switch (_value.Type())
    {
      case YAML::NodeType::Undefined:
      case YAML::NodeType::Null: {
        what += std::string(what.length() > 0 ? "; " : "") +
                "The value is Null or Undefined. This is not yet supported. Input Node: ''" + std::to_string(node) +
                "'' Abort.";
        ret.reset(YAML::Node(YAML::NodeType::Null));
        return false;
      }
      break;
      case YAML::NodeType::Scalar: {
        ret[key] = _value;
      }
      break;
      case YAML::NodeType::Sequence: {
        if(_value.size()<=0)
        {
          what += std::string(what.length() > 0 ? "; " : "") +
                "The Sequence is a null list. Input Node: ''" + std::to_string(node) +
                "'' Abort.";
          ret.reset(YAML::Node(YAML::NodeType::Null));
          return false;
        }
        auto const & first_item = _value[0];
        switch (first_item.Type())
        {
          case YAML::NodeType::Undefined:
          case YAML::NodeType::Null: {
            what += std::string(what.length() > 0 ? "; " : "") +
                    "The value of the first element of the sequence is Null or Undefined. This is not yet supported. "
                    "Input Node: ''" + std::to_string(node) + "'' Abort.";
            ret.reset(YAML::Node(YAML::NodeType::Null));
            return false;
          }
          break;
          case YAML::NodeType::Scalar: { 
            ret[key] = YAML::Node(YAML::NodeType::Sequence);
            for (std::size_t i=0;i<_value.size();i++) 
            {
              ret[key].push_back(_value[i]);
            }
          }
          break;
          case YAML::NodeType::Sequence:
          case YAML::NodeType::Map: {
            auto key_autogenerated = key + "_autogenerated_from_sequence_of_" + std::to_string(first_item.Type());
            
            YAML::Node items = YAML::Node(YAML::NodeType::Map);
            items["size"] = _value.size();
            for (std::size_t i=0;i<_value.size();i++) 
            {
              auto const & item = _value[i];
              std::string record_key = "record_" + std::to_string(i);
              if (item.IsSequence())
              {
                items[record_key] = YAML::Node(YAML::NodeType::Sequence);
                for (std::size_t j=0; j<item.size(); j++)
                {
                  items[record_key].push_back(item[j]);
                }
              }
              else  // IsMap
              {
                items[record_key] = item;
              }
            }
            YAML::Node new_map = YAML::Node(YAML::NodeType::Map);
            if (!ros2_yaml_encoder(items, new_map, what))
            {
              return false;
            }
            ret[key_autogenerated] = new_map;
          }
          break;
        }
      }
      break;
      case YAML::NodeType::Map: {
        YAML::Node new_map = YAML::Node(YAML::NodeType::Map);
        if (!ros2_yaml_encoder(_value, new_map, what))
        {
          return false;
        }
        ret[key] = new_map;
      }
      break;
    }
  }

  return true;
}

bool ros2_yaml_decoder(const YAML::Node& node, YAML::Node& ret, std::string& what)
{
  switch (node.Type())
  {
    case YAML::NodeType::Scalar: {
      ret = node;
      return true;
    }
    break;
    case YAML::NodeType::Sequence: {
      ret.reset(YAML::Node(YAML::NodeType::Sequence));
      for (auto it = node.begin(); it != node.end(); ++it)
      {
        YAML::Node leaf;
        if (!ros2_yaml_decoder(*it, leaf, what))
        {
          return false;
        }
        ret.push_back(leaf);
      }
      return true;
    }
    break;
    case YAML::NodeType::Map: {
      for (auto it = node.begin(); it != node.end(); ++it)
      {
        if (!it->first.IsScalar())
        {
          throw std::runtime_error("WIP");
        }
        std::string key = it->first.Scalar();
        if (key[0] == '/')
        {
          key = key.substr(1);
        }
        auto _pos = key.find("_autogenerated_from_sequence_of_");
        if (_pos == std::string::npos)
        {
          YAML::Node leaf;
          if (!ros2_yaml_decoder(it->second, leaf, what))
          {
            return false;
          }
          ret[key] = leaf;
        }
        else
        {
          std::string resolved_key = key.substr(0, _pos);
          if (!node[key]["size"])
          {
            what += std::string(what.length() > 0 ? "; " : "") +
                    ("The key " + key + " does not have the field 'size'. Input Node: ''" + std::to_string(node) +
                     "'' Abort.");
            ret.reset(YAML::Node(YAML::NodeType::Null));
            return false;
          }
          const std::size_t sz = node[key]["size"].as<std::size_t>();
          YAML::Node seq(YAML::NodeType::Sequence);
          for (std::size_t i = 0; i < sz; i++)
          {
            std::string r = "record_" + std::to_string(i);
            if (!node[key][r])
            {
              what += std::string(what.length() > 0 ? "; " : "") +
                      ("The key " + key + " does not have the field '" + r + "'. Input Node: ''" +
                       std::to_string(node) + "'' Abort.");
              ret.reset(YAML::Node(YAML::NodeType::Null));
              return false;
            }
            YAML::Node element;
            if (!ros2_yaml_decoder(node[key][r], element, what))
            {
              return false;
            }
            seq.push_back(element);
          }
          ret[resolved_key] = seq;
        }
      }
      return true;
    }
    break;
    default: {
      what += std::string(what.length() > 0 ? "; " : "") +
              ("The value is " + std::to_string(node.Type()) + ". This is not yet supported. Input Node: ''" +
               std::to_string(node) + "'' Abort.");
      ret.reset(YAML::Node(YAML::NodeType::Null));
      return false;
    }
    break;
  }
  what += std::string(what.length() > 0 ? "; " : "") + ("WEIRD!!! Why am I here?");
  ret.reset(YAML::Node(YAML::NodeType::Null));
  return false;
}

}  // namespace ros2
}  // namespace param
}  // namespace cnr