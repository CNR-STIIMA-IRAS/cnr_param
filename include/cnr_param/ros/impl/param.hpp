#ifndef CNR_PARAM__INCLUDE__CNR_PARAM__ROS__IMPL__PARAM__HPP
#define CNR_PARAM__INCLUDE__CNR_PARAM__ROS__IMPL__PARAM__HPP

#include <exception>
#include <string>

#include <boost/type_index.hpp>
#include <boost/algorithm/string/split.hpp>           // Include for boost::split
#include <boost/algorithm/string/classification.hpp>  // Include boost::for is_any_of

#include <yaml-cpp/yaml.h>

#include <ros/node_handle.h>

#include <cnr_yaml/cnr_yaml.h>

#include <cnr_param/ros/param.h>
#include <cnr_param/ros/param_retriever.h>

namespace cnr
{
namespace param
{
namespace ros
{
/**
 * @brief
 *
 * @return std::shared_ptr<rclcpp::Node>
 */
std::shared_ptr<::ros::NodeHandle>& background_node(std::shared_ptr<::ros::NodeHandle> node = nullptr);

/**
 * @brief
 *
 * @return std::shared_ptr<cnr::param::ros2::ParamRetriever>
 */
std::shared_ptr<ParamRetriever>& param_retriever();

/**
 * @brief
 *
 * @param node_name
 * @param key
 * @param resolved_key
 * @param what
 * @return true
 * @return false
 */
inline bool resolve_autogenerated_names(const std::string& node_name, const std::string& key, std::string&,
                                        std::string& what)
{
  what =
      "Asked for parameter key '" + key + "', but the node '" + node_name + "' does not have it. The parmeters are: ";

  return false;
}

//=====================================================================================================
//
//
/**
 * @brief
 *
 * @tparam T
 * @param key
 * @param ret
 * @param what
 * @param default_val
 * @return true
 * @return false
 */
template <typename T>
inline bool get(const std::string& key, T& ret, std::string& what, const bool& implicit_cast_if_possible)
{
  std::size_t ll = __LINE__;
  try
  {
    ll = __LINE__;
    if (!background_node())
    {
      what = "The node is not initialized. Remeber to call the macro CNR_PARAM_INIT_NODE(<your shared_ptr to node>)";
      return false;
    }

    ll = __LINE__;
    std::string resolved_node_name, resolved_key;
    if (!param_retriever()->resolve_names(key, resolved_node_name, resolved_key, what))
    {
      return false;
    }

    ll = __LINE__;
    ParamDictionary param(key);
    if (!param_retriever()->get_parameter(resolved_node_name, resolved_key, param, what))
    {
      std::cout << "get_parameter failed!" << std::endl;
      return false;
    }

    ll = __LINE__;
    // ========================================================================
    YAML::Node node(YAML::NodeType::Map);
    if (!cnr::param::ros::to_yaml(param, node, what))
    {
      return false;
    }
    // ========================================================================

    ll = __LINE__;
    return cnr::yaml::get(node.begin()->second, ret, what, implicit_cast_if_possible);
  }
  catch (std::exception& e)
  {
    what = std::string(e.what()) + " at line " + std::to_string(ll);
    return false;
  }
  catch (...)
  {
    what = "Unknown exception at line " + std::to_string(ll);
    return false;
  }
}


template <typename T>
bool set(const std::string& key, const T& value, std::string& what)
{

  return false;
}

}  // namespace ros
}  // namespace param
}  // namespace cnr

#endif /* CNR_PARAM__INCLUDE__CNR_PARAM__ROS__IMPL__PARAM__HPP */