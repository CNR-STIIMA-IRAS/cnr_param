
#include <cnr_param/ros2/yaml_formatter.h>
#include <yaml-cpp/node/node.h>
#include <iterator>
#include <iostream>

namespace cnr
{
namespace param
{
namespace ros2
{

std::string to_string(const YAML::NodeType::value& v)
{
  if (v == YAML::NodeType::Undefined)
    return "Undefined";
  if (v == YAML::NodeType::Null)
    return "Null";
  if (v == YAML::NodeType::Sequence)
    return "Sequence";
  if (v == YAML::NodeType::Map)
    return "Map";
  if (v == YAML::NodeType::Scalar)
    return "Scalar";
  return "Unknown";
};

/**
 * @brief
 *
 * @param node
 * @return YAML::Node
 */
YAML::Node ros2_yaml_encoder(const YAML::Node& node)
{
  if (node.IsScalar())
  {
    return node;
  }

  YAML::Node new_node;
  for (auto it = node.begin(); it != node.end(); it++)
  {
    if (!it->first.IsScalar())
    {
      throw std::runtime_error("WIP");
    }
    std::string key = it->first.Scalar();
    if (key[0] == '/')
    {
      key = key.substr(1);
    }

    //
    switch (it->second.Type())
    {
      case YAML::NodeType::Undefined:
        throw std::runtime_error("The value is Undefined. This is not yet supported");
        break;
      case YAML::NodeType::Null:
        throw std::runtime_error("The value is Null. This is not yet supported");
        break;
      case YAML::NodeType::Scalar:
        new_node[key] = it->second;
        break;
      case YAML::NodeType::Sequence: {
        const YAML::Node& seq = it->second;
        switch (seq[0].Type())
        {
          case YAML::NodeType::Undefined:
            throw std::runtime_error("The value is Undefined. This is not yet supported");
            break;
          case YAML::NodeType::Null:
            throw std::runtime_error("The value is Null. This is not yet supported");
            break;
          case YAML::NodeType::Scalar:
            new_node[key] = it->second;
            break;
          case YAML::NodeType::Sequence:
          case YAML::NodeType::Map: {
            auto key_autogenerated = key + "_autogenerated_from_sequence_of_" + to_string(seq[0].Type());
            YAML::Node new_map;
            new_map["size"] = it->second.size();
            for (auto seq_it = seq.begin(); seq_it != seq.end(); seq_it++)
            {
              std::size_t i = std::distance(seq.begin(), seq_it);
              std::string record_key = "record_" + std::to_string(i);
              if (seq[0].IsSequence())
              {
                for (auto record_it = seq_it->begin(); record_it != seq_it->end(); record_it++)
                {
                  new_map[record_key].push_back(*record_it);
                }
              }
              else  // IsMap
              {
                YAML::Node tmp = *seq_it;
                new_map[record_key] = tmp;
              }
            }
            new_node[key_autogenerated] = ros2_yaml_encoder(new_map);
          }
          break;
        }
      }
      break;
      case YAML::NodeType::Map:
        new_node[key] = ros2_yaml_encoder(it->second);
        break;
    }
  }
  return new_node;
}



YAML::Node ros2_yaml_decoder(const YAML::Node& node)
{
  if (node.IsScalar())
  {
    return node;
  }

  bool modified = false;
  YAML::Node new_node;
  switch (node.Type()) 
  {
    case YAML::NodeType::Undefined:
      throw std::runtime_error("The value is Undefined. This is not yet supported");
      break;
    case YAML::NodeType::Null:
      throw std::runtime_error("The value is Undefined. This is not yet supported");
      break;
    case YAML::NodeType::Scalar:;
      break;
    case YAML::NodeType::Sequence:
      modified = true;
      for (auto it = node.begin(); it != node.end(); ++it) 
      {
        new_node.push_back(ros2_yaml_decoder(*it));
      }
      break;
    case YAML::NodeType::Map:
      for (auto it = node.begin(); it != node.end(); ++it)
      {
        if (!it->first.IsScalar())
        {
          throw std::runtime_error("WIP");
        }
        std::string key = it->first.Scalar();
        if (key[0] == '/')
        {
          key = key.substr(1);
        }
        if(key.find("_autogenerated_from_sequence_of_")==std::string::npos)
        {
          new_node[key] = ros2_yaml_decoder(it->second);
          continue;
        }


        modified = true;
        std::string resolved_key = key.substr(0, key.find("_autogenerated_from_sequence_of_"));
        if(!node[key]["size"])
        {
          throw std::runtime_error("The key "+key+" does not have the field 'size'");
        }
        const std::size_t sz = node[key]["size"].as<std::size_t>();
        for(std::size_t i=0; i<sz; i++)
        {
          std::string r = "record_"+std::to_string(i);
          if(!node[key][r])
          {
            throw std::runtime_error("The key "+key+" does not have the field '"+r+"'");
          }
          YAML::Node leaf = node[key][r];
          if(leaf.Type()==YAML::NodeType::Sequence || leaf.Type()==YAML::NodeType::Map)
          {
            leaf = ros2_yaml_decoder(leaf);
          }

          new_node[resolved_key].push_back(leaf);
        }
      }
      break;
  }


  return modified ? new_node : node;
}

}  // namespace ros2
}  // namespace param
}  // namespace cnr